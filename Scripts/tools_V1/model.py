import tensorflow as tf
from tensorflow.keras import applications, layers, models


class TNNUtilsModel(tf.keras.models.Model):
    """
    Model class for training a Siamese Neural Network. Triplet loss
    is calculated from embeddings generated by a CNN model.
    """
    def __init__(self, snn, loss_margin=0.5):
        super(TNNUtilsModel, self).__init__()
        self.loss_margin = loss_margin
        self.loss_tracker = tf.keras.metrics.Mean(name="loss")
        self.snn = snn

    def call(self, inputs):
        return self.snn(inputs)

    @property
    def metrics(self):
        return [self.loss_tracker]

    def test_step(self, data):
        """
        Perform following tasks as testing step:
        1. Use tf.GradientTape to Track automatically calculated derivatives/gradients
        2. Get embedding distances
        3. Calculate loss
        """
        distance_ap, distance_an = self.snn(data)
        loss = tf.maximum(distance_ap + self.loss_margin - distance_an, 0.0)
        self.loss_tracker.update_state(loss)
        return {"loss": self.loss_tracker.result()}

    def train_step(self, data):
        """
        Perform following tasks as training step:
        1. Use tf.GradientTape to Track automatically calculated derivatives/gradients
        2. Get embedding distances
        3. Calculate loss
        4. Access gradient
        5. Apply gradient on optimizer
        6. Update accuracy parameters
        """
        with tf.GradientTape() as tape:
            distance_ap, distance_an = self.snn(data)
            loss = tf.maximum(distance_ap + self.loss_margin - distance_an, 0.0)

        g = tape.gradient(loss, self.snn.trainable_weights)

        self.optimizer.apply_gradients(
            zip(g, self.snn.trainable_weights)
        )
        self.loss_tracker.update_state(loss)
        return {"loss": self.loss_tracker.result()}


class TNUtilsModelBlocks:
    """
    This class contains different functions for the creation of embedding models
    based on EfficientNetV2B1, ResNet50 or ResNet101V2 architectures, and
    corresponding siamese neural networks.
    """
    def __init__(self):
        self.distance_layer = TNUtilsModelDistanceLayer()
        self.img_size = 224
        self.num_channels = 3
        self.shape_input = (self.img_size, self.img_size, self.num_channels)

    @staticmethod
    def callbacks_fn(checkpoint_filepath, tensorboard_logdir):
        """Create training callbacks."""
        model_checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(
            filepath=checkpoint_filepath,
            save_weights_only=True,
            monitor='val_loss',
            mode='min',
            save_best_only=True)

        tensorboard_callback = tf.keras.callbacks.TensorBoard(
            log_dir=tensorboard_logdir
        )
        return model_checkpoint_callback, tensorboard_callback

    def fn_layers_input(self):
        """Convenience function to create three input layers."""
        anchor_input = tf.keras.layers.Input(name="anchor", shape=self.shape_input)
        positive_input = tf.keras.layers.Input(name="positive", shape=self.shape_input)
        negative_input = tf.keras.layers.Input(name="negative", shape=self.shape_input)
        return anchor_input, positive_input, negative_input

    @staticmethod
    def fn_validate_model(model_name_original, model_names_expected):
        """Check if model name corresponds to expected model name."""
        assert model_name_original in model_names_expected,\
            f"Wrong model architecture passed to this function {model_name_original}" \
            "Maybe you were looking for the other function to create a SNN model?"

    def snn_embedding_resnet50_make(self):
        """
        Create an embedding model based on ResNet50 for the Siamese Neural Network.
        """
        print(tf.__version__)
        if tf.__version__ == "2.11.0":
            base_cnn = applications.resnet.ResNet50(
                weights="imagenet",
                input_shape=self.shape_input,
                include_top=False
            )
        else:
            raise DeprecationWarning("Please use TensorFlow version 2.8.0 or newer.")

        flatten = layers.Flatten()(base_cnn.output)
        dense1 = layers.Dense(512, activation="relu")(flatten)
        dense1 = layers.BatchNormalization()(dense1)
        dense2 = layers.Dense(256, activation="relu")(dense1)
        dense2 = layers.BatchNormalization()(dense2)
        output = layers.Dense(256)(dense2)

        embedding = models.Model(base_cnn.input, output, name="Embedding_resnet50")

        trainable = False
        for layer in base_cnn.layers:
            if layer.name == "conv5_block1_out":
                trainable = True
            layer.trainable = trainable

        return embedding

    def snn_network_resnet_make(self, model_embedding):
        """Instantiate a Siamese Neural Network based on the ResNet architecture."""
        self.fn_validate_model(model_embedding.name, ['Embedding_resnet50'])
        if model_embedding.name == 'Embedding_resnet50':
            model_network_name = "snn_resnet50"
        else:
            model_network_name = 'snn_resnet101V2'
        anchor_input, positive_input, negative_input = self.fn_layers_input()

        distances = self.distance_layer(
            model_embedding(tf.keras.applications.resnet_v2.preprocess_input(anchor_input)),
            model_embedding(tf.keras.applications.resnet_v2.preprocess_input(positive_input)),
            model_embedding(tf.keras.applications.resnet_v2.preprocess_input(negative_input)),
        )
        siamese_network = tf.keras.models.Model(
            inputs=[anchor_input, positive_input, negative_input], outputs=distances, name=model_network_name
        )
        return siamese_network


class TNUtilsModelDistanceLayer(layers.Layer):
    """
    Layer class for calculation of distances between positive
    and anchor embeddings and negative and anchor embeddings.
    """
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    @staticmethod
    def call(anchor, positive, negative):
        """
        Please note this function is named 'call', as it will be called
        in '__called__' after 'build()' has been called
        """
        ap_distance = tf.reduce_sum(tf.square(anchor - positive), -1)
        an_distance = tf.reduce_sum(tf.square(anchor - negative), -1)
        return ap_distance, an_distance
